# 1806번: 부분합
- [백준 두 포인터(Two Pointers) 알고리즘 1806번: 부분합](https://www.acmicpc.net/problem/1806)

## 풀이
- L: 구간의 왼쪽 끝
- R: 구간의 오른쪽 끝
- Sum: [L, L+1, …, R] 구간의 합 
1. 왼쪽 시작 L의 이동 횟수 N 번
2. 오른쪽 끝 R을 이전의 R부터 시작해서 이동
3. L, R이 각자 최대 N 번 이동: O(N)

## 문제
- 10,000 이하 자연수로 이루어진 길이 N 수열이 주어짐
- 이 수열에서 연속된 수들의 부분합 중 그 합이 S 이상이 되는 것 중 가장 짧은 것의 길이를 구하는 프로그램
  - 순서를 지키며 차례대로 부분합을 구했을 때 가장 짧은 것의 길이 -> 두 포인터 키워드
  - 부분합 최악의 경우: 100,000 * 10,000 = 10^9 (10억) (int)
- Java11 시간 제한: 1초
  - 모두 탐색: O(N^2)은 O(10^10): 100억 이므로 시간 초과

## 입력
- 첫째 줄: N(수열의 길이) S(기준 값)
  - 10 <= N <= 100,000 자연수
  - 0 < S <= 100,000,000 (1억) (int)
- 둘째 줄: 길이 N 수열의 각 원소가 공백으로 구분되어 입력
  - 각 원소는 10,000 이하의 자연수 (int[])

## 출력
- 구하고자 하는 최소의 길이
  - 만일 S 값 이상을 만족하는 부분합이 존재하지 않을 때 0을 출력
  - 최악의 경우: 길이가 N 이므로 (int)

## 예제
- 입력
```text
10 15
5 1 3 5 10 7 4 9 2 8
```
- 출력
```text
2
```

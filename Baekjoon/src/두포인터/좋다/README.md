# 1253번: 좋다
- [백준 두 포인터(Two Pointers) 알고리즘 1253번: 좋다](https://www.acmicpc.net/problem/1253)

## 풀이
1. 주어진 배열 정렬: O(N log N)
2. 타겟 수 결정: O(N)
3. 다른 수 2개를 결정해서 타겟 수가 만들어지는지 확인: O(N)
   - L: 최소값 1 부터 시작, R: 최대값 N 부터 시작
   - 최소 + 최대 < target 인 경우
     - 최소 입장에서는 최선책을 만난 상태, 최소값을 더 큰 값으로 갱신
   - 최소 + 최대 > target 인 경우
       - 최대 입장에서는 최선책을 만난 상태, 최대값을 더 작은 값으로 갱신
- 총 시간 복잡도: O(N^2)

## 문제
- N개의 수 중 어떤 수가 다른 수 두개의 합으로 나타낼 수 있으면 좋다(GOOD)
- N개의 수가 주어지면 그 중 좋은 수의 개수는 몇 개인지 출력하는 문제
  - 수의 위치가 다르면 값이 같아도 다른 수 (중복 허용)
  - 2 4 2 가 주어지면 좋은 수는 4

## 입력
- 첫째 줄: N(수의 개수)
  - 1 <= N <= 2,000
- 둘째 줄: N개의 수가 공백을 구분으로 입력
  - |각 수| <= 1,000,000,000 인 정수 (int[])
  - sum: 최대 10억 + 10억 - 1, (int)

## 출력
- 첫째 줄: 좋은 수의 개수

## 예제
- 입력
```text
10
1 2 3 4 5 6 7 8 9 10
```
- 출력
```text
8
// 좋은 수: 3, 4, 5, 6, 7, 8, 9, 10
```
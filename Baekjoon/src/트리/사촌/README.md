# 9489번: 사촌
- [백준 트리 알고리즘 9489번: 사촌](https://www.acmicpc.net/problem/9489)

## 풀이
- 정답의 최대치: 1 3 4 6 8 9 10 11 12 13 .... 일 때, 1 3 4 6을 제외한 996개의 노드가 사촌노드 (int)
- 부모 노드 설정
  - 연속한 수를 가진 정점을 모두 last 의 자식으로 묶는다. (last 의 초기값은 1)
  - 연속한 수가 아니면 last + 1의 자식으로 묶고 위 과정을 반복.
- 사촌 찾기
  - k의 index 번호를 찾는다.
  - 사촌은 부모의 부모가 같고 부모가 다른 노드들 (parent[parent[]]는 같고, parent[]는 다른 노드들)

## 문제
- 증가하는 정수 수열을 이용해서 트리를 만드는 방법
  - 첫 번째 정수는 트리의 루트 노드
  - 다음에 등장하는 연속된 수의 집합은 루트의 자식. 이 집합에 포함되는 수의 첫 번째 수는 항상 루트 노드 + 1보다 크다.
    - ex: 루트 노드(1), 다음 노드(3)
  - 그 다음 부터 모든 연속된 수의 집합은 아직 자식이 없는 노드의 자식이 된다. 그러한 노드가 여러개 일 때 가장 작은 수를 가지는 노드의 자식이 된다.
  - 집합은 수가 연속하지 않는 곳에서 구분된다.
- 두 노드의 부모는 다르지만, 두 부모가 형제(sibling)일 때 두 노드를 사촌이라고 한다.
- 특정 노드 번호 k가 주어졌을 때, k의 사촌의 수를 구하는 문제

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 입력의 마지막 줄에는 `0 0`
- 각 테스트 케이스 첫째 줄: n(노드의 수) k(사촌의 수를 구해야 하는 노드 번호)
  - 1 <= n <- 1,000 (int)
  - 1 <= k <= 1,000,000 (int)
- 각 테스트 케이스의 둘째 줄: n개의 수
  - 모든 수는 1 이상, 1,000,000 이하
  - 입력으로 주어지는 수열은 항상 오름차순
  - k는 항상 수열에 포함된 수

## 출력
- 각 테스트 케이스 마다 k의 사촌의 수를 출력

## 예제
- 입력
```text
10 15
1 3 4 5 8 9 15 30 31 32
12 9
3 5 6 8 9 10 13 15 16 22 23 25
10 4
1 3 4 5 8 9 15 30 31 32
0 0
```
- 출력
```text
5
1
0
```
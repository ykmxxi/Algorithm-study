# 14890번: 경사로
- [백준 완전 탐색(Brute Force) 알고리즘 14890: 경사로](https://www.acmicpc.net/problem/14890)

## 풀이
- 모든 행과 열을 각각 탐색 O(N^2 이내), N 이 최대 100이므로 약 10^4 이내로 가능
- 다음 칸과 길이차가 1이 아니다 -> 종료
- 경사로를 놓을 수 없는 상황이다 -> 종료
  - 놓으려는 칸에 이미 경사로가 놓여있는 경우
  - 놓으려는 칸의 높이가 맞지 않는 경우(경사로를 놓을 길이가 부족한 경우)

## 문제
- 크기가 N x N 지도가 존재하고, 각 칸에 높이가 적혀있음
- 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려는 문제
  - 길: 한 행 or 한 열 전부
  - 즉, 길은 한쪽 끝에서 다른쪽 끝까지 지나가는 것
  - 길은 총 2N개 존재
- 길을 지나가는 조건
  - 길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다
  - 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. (경사로는 높이가 항상 1, 길이가 L)
    - 경사로 개수는 매우 많아 부족할 일이 없음
    - 경사로는 낮은 칸과 높은 칸을 연결
- 경사로를 놓을 수 있는 조건
  - 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 함
  - 낮은 칸과 높은 칸의 차이는 1이어야 한다
  - 경사로를 놓을 칸의 높이는 모두 같아야 하고 L개의 칸이 연속되어 있어야 한다
- 경사로를 놓을 수 없는 곳
  - 경사로를 놓은 곳에 또 경사로를 놓는 경우
  - 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
  - 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
  - 경사로를 놓다가 범위를 벗어나는 경우

## 입력
- 첫째 줄: N L
  - 2 <= N <= 100
  - 1 <= L <= N
- 둘째 줄부터 N개의 줄에 지도가 주어짐
  - 각 칸의 높이는 10이하의 자연수

## 출력
- 첫째 줄: 지나갈 수 있는 길의 개수

## 예제
- 입력
```text
// 예제 1
6 2
3 3 3 3 3 3
2 3 3 3 3 3
2 2 2 3 2 3
1 1 1 2 2 2
1 1 1 3 3 1
1 1 2 3 3 2

// 예제 2
6 2
3 2 1 1 2 3
3 2 2 1 2 3
3 2 2 2 3 3
3 3 3 3 3 3
3 3 3 3 2 2
3 3 3 3 2 2
```
- 출력
```text
// 예제 1
3

// 예제 2
7
```
